# otus-cpp-basic-hw4
Учебный репозиторий курса Otus C++ Developer Basic, домашнее задание к занятию 9

## Цель:

На практике познакомимся с классами и методами, участвуя в разработке простого прототипа физического симулятора.
Воспользоваться одной из сильных сторон ООП – возможностью проектирования программы в виде набора слабо связанных классов.

## Описание:

Требуется реализовать одну из ключевых компонент – класс шара **Ball** с тем
интерфейсом, на который рассчитан код коллег, и обеспечить чтение из файла модели
для симуляции. В процессе работы потренироваться читать, использовать и
дорабатывать сторонний код, написанный в объектном стиле.

Симулятор реализует упрощенную физическую модель, в которой с постоянной
скоростью движутся шары разного размера, отталкиваясь при столкновении друг с
другом или с границей области. Физический движок уже написан, не требуется
разбираться в его устройстве. Достаточно знать, что ему требуется объект **Ball** с
таким интерфейсом:
``` C++
class Ball {
    public:
        void setVelocity(const Velocity& velocity);// задать скорость шара
        Velocity getVelocity() const; // получить скорость шара
        void setCenter(const Point& center); // задать координаты центра шара
        Point getCenter() const; // получить центр шара
        double getRadius() const; // получить радиус шара
        double getMass() const; // получить массу шара
};
```
Для отображения шара графическим движком нужно реализовать метод **draw**:
``` C++
class Ball {
    public:
        // ...
        void draw(Painter& painter) const; // нарисовать шар, используя painter
};
```
Метод **draw** принимает на вход контекст для рисования – **painter**. Для отображения
шара на плоскости (вид сверху) нам будет достаточно вызвать метод **painter**’а для
рисования круга.

Последнее, что требуется сделать – завершить реализацию конструктора **World::World**, 
в котором читаем модель для симуляции из файла **worldFilePath**:
```C++
World::World(const std::string& worldFilePath) {
    // ...
    while (stream.good()) {
        stream >> x >> y >> vx >> vy;
        stream >> red >> green >> blue;
        stream >> radius;
        stream >> std::boolalpha >> isCollidable;
        // в этом месте необходимо сконструировать объект
        // нашего класса Ball ball(...);
        // и поместить его в вектор шаров
        // вызовом balls.push_back(ball);
    }
}
```
В конструкторе **World** уже реализовано чтение модели, включая всю необходимую информацию 
о шарах **(x, y, vx, vy…)**. В исходном коде даны подробные комментарии о физическом смысле этих переменных. 
Необходимо немного доработать тело конструктора **World** для создания из каждой записи о шаре объектов **Ball** и помещения созданных шаров в вектор **balls**.

Требуется доработать часть кодовой базы, с которой мы целиком не знакомы. 
Важно понять, какие модули предстоит изменить и сфокусироваться на их изучении. В нашем случае это классы **Ball** и 
частично **World**. В интерфейсе **Ball** используются простые примитивы **Velocity** и **Point**, которые объявлены и 
реализованы в соответствующих файлах.

Существенная часть реализации проекта помещена в каталог **black_box** – изучением этих исходных файлов не требуется для 
выполнения задания. В частности, там находится реализация графического интерфейса. 
Для отрисовки шаров достаточно познакомится с публичным интерфейсом (*public* методами) класса **Painter** и
воспользоваться методом рисования круга 
```C++
Painter::draw(const Point& center, double radius, const Color& color).
```

В проекте используется библиотека [SFML](https://www.sfml-dev.org/).<br>
В ОС Windows и MacOS сборка проекта должна заработать “из коробки”: библиотека **SFML** и ее зависимости загружаются и собираются автоматически – требуется лишь доступ в интернет.<br>
В ОС Linux для установки её и её зависимостей возможны два пути.
1. *Рекомендуемый* - установить пакет разработчика **SFML**, используя пакетный
менеджер ОС.<br>
Например, в Debian и его производных (Ubuntu) для этого требуется выполнить
команду **sudo apt-get install libsfml-dev**
2. *Альтернативный* путь – обеспечить сборку **SFML** из исходных кодов. Этот
процесс запускается автоматически, если в системе не найден пакет **SFML**. В Linux для успешной сборки **SFML** требуется установить [зависимости](https://www.sfml-dev.org/tutorials/2.6/compile-with-cmake.php#installing-dependencies).

## Задание

Доработать исходный код из примера, реализовав приведенные выше методы класса
**Ball** (их объявления и реализации-заглушки уже есть в файлах **Ball.hpp** и **Ball.сpp** соответственно). Для этого понадобится добавить несколько полей. При необходимости добавить любые другие методы (например, для создания объектов нашего класса в конструкторе **World** будет удобно добавить конструктор класса **Ball**).

Ожидается, что после доработки исходный код программы будет компилироваться и
запускаться командой **./physics <путь к файлу smile.txt>**, например, **./physics
/home/user/physics/data/smile.txt** (тестовая модель находится в подкаталоге **data** примера), а в ходе работы программы увидим процесс симуляции столкновений
шаров, завершающийся упорядоченной структурой.

## Дополнительные задания
### 1. Рефакторинг
***Сложность 1/5***<br>
Реализация загрузки модели из файла (см. конструктор класса **World**, пометку *//TODO: хорошее место для улучшения*) выглядит довольно неказисто – сейчас, например, читаем в специально объявленные исключительно для этого переменные типа **double**: **x, y** и **red**, **green**, **blue** вместо того, чтобы сразу получать объекты **Point** и **Color** соответственно. Было бы здорово упростить этот код, выделив отдельные функции чтения объектов из **std::istream**. Для этого удобно воспользоваться перегрузкой оператора ввода из потока:
```C++
std::istream& operator>>(std::istream& stream, <ваш класс>& variable) {...}
```
### 2. Призрачные шары
***Сложность 2/5***<br>
Новое требование – в некоторых случаях требуется отключить обработку коллизий определенных шаров. При чтении модели из файла в теле конструктора **World** помимо прочих параметров каждого шара получаем флаг **isCollidable**. Надо доработать программу так, чтобы шары, для которых **isCollidable==false**, не сталкивались с другими объектами, а проходили сквозь них. Небольшая сложность в том, что для этого понадобится дополнить реализацию не только класса **Ball**, но и код в **Physics.cpp**, т.к. обработка **isCollidable** еще не реализована на стороне физического движка, а его разработчик в отпуске на пляже.

Для самопроверки запустите **./physics <путь к файлу elephant.txt>**, например, **./physics /home/user/physics/data/elephant.txt** – ожидается, что по завершению симуляции вновь увидим некоторую упорядоченную структуру.

### 3. Наводим красоту
***Сложность 5/5***<br>
Сделать столкновения шаров более зрелищными. Графический движок
примитивен, но даже с его ограниченными возможностями мы можем сымитировать разлетающиеся от места столкновения маленькие круглые частицы, исчезающие через небольшое время после удара. Это исключительно визуальный эффект, поэтому чтобы не “ломать” физическую часть симулятора временные объекты лучше не представлять в виде объектов **Ball** в векторе **balls**. Хорошим решением будет создать новый класс, например, **Dust**, который будет хранить координаты, скорости и оставшееся время отображения частиц, образованных в результате столкновения. Координаты частиц можно обновлять каждый тик симуляции по аналогии с обновлением положения шаров, но для простоты игнорируя коллизии, т.е. просто прибавляя вектор скорости.
Все **Dust**’ы, опять же по аналогии с шарами, можно хранить в новом **std::vector** в
классе **World**. Желательно удалять объекты, отображение которых завершено.

